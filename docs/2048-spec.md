# 2048 Game — Functional Specification and Exhaustive Test Plan

## 1) Purpose and Scope

This document defines the requirements, rules, data model, and test cases for implementing the classic “2048” puzzle. It is written for an AI agent or developer to build a **bug-free, deterministic, and testable** implementation with clear separation between the **engine (pure logic)** and **UI/IO**.

The spec targets a 4×4 grid (configurable), keyboard/touch input, scoring, win/lose detection, undo/redo (configurable), serialization, and deterministic RNG for tests.

---

## 2) Glossary

* **Cell**: A single square on the board.
* **Tile**: A non-zero value in a cell (power of two).
* **Move**: One of {Up, Down, Left, Right}.
* **Compression**: Sliding tiles toward the move direction, removing gaps.
* **Merge**: Combining two adjacent tiles of equal value during a move.
* **Spawn**: Adding a new tile after a **state-changing** move.
* **State-changing move**: A move whose application changes the board (positions or values).
* **No-op move**: A move with no effect on the board; **must not spawn** a tile.

---

## 3) Game Rules (Canonical)

1. The board is an **N×N grid**; default N=4.
2. **Initial state**: Empty board, then spawn 2 tiles (values 2 or 4 as per RNG). Default probabilities: 90% → 2, 10% → 4.
3. On each move:

   * For each line (row or column depending on direction), **compress** tiles fully toward the move direction.
   * Then **merge** adjacent equal tiles once per move pass, from the side of motion (see §4 Merge Order).
   * After a merge, the resulting tile is the **sum**, and the cell behind it becomes empty.
   * After all merges in the line, **compress again** to remove new gaps.
4. **Single-merge per tile per move**: A tile that is created by a merge **cannot** merge again in the same move.
5. **Spawning**: After a **state-changing** move, spawn exactly one new tile (2 with p=0.9, 4 with p=0.1) in a random empty cell.
6. **Win condition**: Reaching a tile with value **2048** (configurable `WIN_VALUE`); the implementation must support:

   * `stop_on_win = true`: game enters **Won** terminal state; no further input accepted.
   * `stop_on_win = false`: game enters **Won (continue)**; play can continue; final state is **Lost** when no moves remain.
7. **Lose condition**: No legal moves (no empty cells and no adjacent equal tiles in any direction).
8. **Scoring**: The score increases by the **sum of all merged tile values created during the move**. No points for compression or spawns.
9. **No-op**: If a move does not change the board, it **must not** spawn a tile and **must not** change score or history.

---

## 4) Determinism, Merge Order, and RNG

To ensure reproducibility:

* **Merge order**:

  * **Left**: process rows left→right; compare each index `i` with `i+1`.
  * **Right**: process rows right→left; compare `i` with `i−1`.
  * **Up**: process columns top→bottom; compare `i` with `i+1`.
  * **Down**: process columns bottom→top; compare `i` with `i−1`.
* **RNG control for tests**:

  * Production: uniform random empty cell; value 2 with 0.9, 4 with 0.1.
  * Tests: replace RNG with **Spawn Script** (see §7.2). If omitted, use seeded RNG.
* **Equality and types**: Tiles are integers (32-bit safe). Zero means empty.

---

## 5) Data Model and API (Engine)

### 5.1 State

```
Board: N×N integer matrix (0 = empty; {2,4,8,...})

GameState:
  board: int[N][N]
  score: int
  status: enum { Playing, Won, Lost }
  win_value: int (default 2048)
  stop_on_win: bool (default true)
  rng: RNG | null
  history: optional stack for undo (see §6)
  future: optional stack for redo (see §6)
```

### 5.2 Public Engine API (No UI inside)

```
init(config): GameState
  - config: { N=4, win_value=2048, stop_on_win=true, initial_spawns=2, rng | spawn_script }

move(state, direction): GameState
  - direction ∈ {Left, Right, Up, Down}
  - If board changes: update board + score, maybe set status to Won/Lost, spawn new tile.
  - If no change: return identical state; do not spawn.

legal_moves(state): Set<direction>

can_move(state): boolean

serialize(state): string  // stable JSON
deserialize(json): GameState

undo(state): GameState (if enabled)
redo(state): GameState (if enabled)
```

### 5.3 Coordinates & Notation

* Rows indexed **0..N−1** top→bottom; columns **0..N−1** left→right.
* Board notation in tests: 4 lines with 4 integers separated by spaces; `0` means empty.

Example:

```
2 0 2 4
0 4 0 4
0 0 0 0
0 0 0 0
```

---

## 6) Undo/Redo (Optional but Testable)

* When **a state-changing move** occurs:

  * Push **pre-move** state onto `history`.
  * Clear `future`.
* **undo** pops from `history` and pushes current onto `future`.
* **redo** pops from `future` and pushes current onto `history`.
* **No-op moves** must **not** alter history.

---

## 7) Testing Strategy

### 7.1 Test Types

* **Unit tests**: line compression/merge; single-line scenarios; spawn logic; scoring; status flags.
* **Integration tests**: full moves over the board; with/without merges; multi-line merges; win/lose transitions.
* **End-to-end (E2E)**: scripted sequences with deterministic spawns; undo/redo; serialization round-trip.
* **Property-based tests** (where supported): invariants (§7.4).
* **Fuzz tests**: random sequences with seeded RNG → ensure no crashes; invariants hold.

### 7.2 Deterministic Spawn Script

For exact expectations, tests can supply:

```
SpawnScript = list of { row, col, value } consumed in order after each state-changing move.
```

If SpawnScript is exhausted, either:

* Fall back to seeded RNG, **or**
* Throw test harness error (recommended for strictness).

### 7.3 Randomness Probabilities (Production)

* Value 2 with probability 0.9; value 4 with 0.1.
* Empty cell chosen uniformly.
* Tests should not assert probabilistic distributions; they assert **deterministic sequences** via SpawnScript.

### 7.4 Invariants (Property Checks)

* After any move:

  * All tiles are powers of two or zero.
  * Number of non-zero tiles after a **state-changing** move equals `prev_nonzero − merges_count + 1` (the `+1` is the spawn), and equals `prev_nonzero` for a **no-op**.
  * Score increases by exactly the sum of merged tile values created in that move.
  * Board dimensions and indices remain valid.
  * `Won` iff at least one tile ≥ `win_value`; `Lost` iff `legal_moves` is empty.
  * Undo/redo preserves exact past/future states.

---

## 8) Unit Tests — Line Mechanics

Use 1D lines to verify compression/merge rules. Notation: input → after compression/merge → final after second compression; `scoreΔ` noted.

#### U1. Pure compression (no merges)

* L1: `[2, 0, 2, 0]` moving **Left** (line perspective) → compress: `[2,2,0,0]` → merges? none → final `[2,2,0,0]`, `scoreΔ=0`.
* L2: `[0,0,0,4]` Left → `[4,0,0,0]`, `scoreΔ=0`.

#### U2. Single merge

* L3: `[2,2,0,0]` Left → compress `[2,2,0,0]` → merge at (0,1) → `[4,0,0,0]` → compress `[4,0,0,0]`, `scoreΔ=4`.

#### U3. Triple with single merge at the side of motion

* L4: `[2,2,2,0]` Left → compress `[2,2,2,0]` → merge first pair → `[4,0,2,0]` → compress `[4,2,0,0]`, `scoreΔ=4`.

  * Confirms **no chain merge** for the newly created 4 in same move.

#### U4. Double independent merges

* L5: `[2,2,4,4]` Left → compress `[2,2,4,4]` → merges: positions (0,1)→4 and (2,3)→8 → `[4,0,8,0]` → compress `[4,8,0,0]`, `scoreΔ=12`.

#### U5. Gapped merges after compression

* L6: `[2,0,2,2]` Left → compress `[2,2,2,0]` → merge first pair → `[4,0,2,0]` → compress `[4,2,0,0]`, `scoreΔ=4`.

#### U6. No merge across more than one tile

* L7: `[2,4,4,0]` Left → compress `[2,4,4,0]` → merge only the 4s → `[2,8,0,0]`, `scoreΔ=8`.

#### U7. Rightward direction symmetry

* L8: `[0,2,2,2]` Right → compress `[0,2,2,2]`→ right-merge from rightmost pair first → `[0,2,4,0]` → compress `[0,2,4,0]`, `scoreΔ=4`.

#### U8. No-op line

* L9: `[2,4,8,16]` Left → unchanged, `scoreΔ=0`. Must register as no-op.

---

## 9) Integration Tests — Full Board Moves (Deterministic Spawns)

**Notation per test:**

* **Given** board (before move)
* **Move**: direction
* **SpawnScript** (if the move changes state): first element consumed `{r,c,v}`
* **Expect**: board after move and spawn; `scoreΔ`; `status`; spawn used.

### I1. Simple slide with spawn

Given:

```
2 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
```

Move: Left
SpawnScript: `{row:0,col:1,value:2}`
Expect (slide only; then spawn at (0,1)=2):

```
2 2 0 0
0 0 0 0
0 0 0 0
0 0 0 0
```

`scoreΔ=0`, `status=Playing`.

### I2. Merge then spawn

Given:

```
2 2 0 0
0 0 0 0
0 0 0 0
0 0 0 0
```

Move: Left
SpawnScript: `{1,3,2}`
Expect:

```
4 0 0 0
0 0 0 2
0 0 0 0
0 0 0 0
```

`scoreΔ=4`, `status=Playing`.

### I3. Two merges on different rows

Given:

```
2 2 0 0
4 4 0 0
0 0 0 0
0 0 0 0
```

Move: Left
SpawnScript: `{2,2,2}`
Expect:

```
4 0 0 0
8 0 0 0
0 0 2 0
0 0 0 0
```

`scoreΔ=12`, `status=Playing`.

### I4. No-op must not spawn

Given:

```
2 4 8 16
32 64 128 256
2 4 8 16
32 64 128 256
```

Move: Left
SpawnScript: `{0,0,2}`  // ignored if no-op
Expect: **unchanged board**, `scoreΔ=0`, `status=Playing`. **No spawn consumed**.

### I5. Rightward merge order (no double merge)

Given:

```
0 2 2 2
0 0 0 0
0 0 0 0
0 0 0 0
```

Move: Right
SpawnScript: `{1,1,2}`
Expect:

```
0 0 2 4
0 2 0 0
0 0 0 0
0 0 0 0
```

`scoreΔ=4`.

### I6. Up move with vertical merges

Given:

```
2 0 2 0
2 0 2 0
0 0 0 0
0 0 0 0
```

Move: Up
SpawnScript: `{3,3,4}`
Expect:

```
4 0 4 0
0 0 0 0
0 0 0 0
0 0 0 4
```

`scoreΔ=8`.

### I7. Down move with stacked merges and compression

Given:

```
2 0 2 0
0 0 2 0
2 0 0 0
2 0 2 0
```

Move: Down
SpawnScript: `{0,1,2}`
Expect:

```
0 0 0 0
0 0 0 0
2 0 2 0
4 0 4 0
```

`scoreΔ=8`, then spawn `(0,1)=2`:

```
2 0 0 0
0 0 0 0
2 0 2 0
4 0 4 0
```

### I8. Ensure single-merge per tile

Given:

```
2 2 4 0
0 0 0 0
0 0 0 0
0 0 0 0
```

Move: Left
SpawnScript: `{0,3,2}`
Expect:

```
4 4 0 2
0 0 0 0
0 0 0 0
0 0 0 0
```

`scoreΔ=4`.

### I9. Spawn placement uses script strictly

Given:

```
4 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
```

Move: Right
SpawnScript: `{3,3,4}`
Expect:

```
0 0 0 4
0 0 0 0
0 0 0 0
0 0 0 4
```

`scoreΔ=0`.

### I10. Multiple merges per row but one per tile

Given:

```
2 2 2 2
4 0 4 4
0 0 0 0
0 0 0 0
```

Move: Left
SpawnScript: `{2,3,2}`
Expect stepwise:

* Row0: `[2,2,2,2]` → merges at (0,1)→4 and (2,3)→4 → `[4,0,4,0]` → compress `[4,4,0,0]`.
* Row1: `[4,0,4,4]` → compress `[4,4,4,0]` → merge first pair → `[8,0,4,0]` → compress `[8,4,0,0]`.
  Final board:

```
4 4 0 0
8 4 0 0
0 0 0 2
0 0 0 0
```

`scoreΔ=4+4+8 = 16`.

### I11. Win detection (stop\_on\_win = true)

Given:

```
1024 1024 0 0
0    0    0 0
0    0    0 0
0    0    0 0
```

Config: `stop_on_win=true`, `win_value=2048`
Move: Left
SpawnScript: `{3,3,2}`  // should not be used if status becomes Won and engine stops immediately after move resolution and before spawn.
Expect:

```
2048 0 0 0
0    0 0 0
0    0 0 0
0    0 0 0
```

`scoreΔ=2048`, `status=Won`, **no spawn**.

### I12. Win (continue = true)

Same Given, but `stop_on_win=false`.
Move: Left
SpawnScript: `{3,3,2}` must be used.
Expect:

```
2048 0 0 0
0    0 0 0
0    0 0 0
0    0 0 2
```

`scoreΔ=2048`, `status=Won (continue)`.

### I13. Lose detection

Given (no merges, no empties):

```
2 4 2 4
4 2 4 2
2 4 2 4
4 2 4 2
```

`can_move=false`, `status=Lost`.

### I14. No-op must not consume spawn script

Given:

```
2 4 8 16
0 0 0 0
0 0 0 0
0 0 0 0
```

Move: Up (no change)
SpawnScript initially: `[{1,1,2}, {2,2,4}]`
Expect: board unchanged; script remains **unchanged**.

### I15. Sequential moves with scripts consumed in order

Given:

```
2 2 0 0
0 0 0 0
0 0 0 0
0 0 0 0
```

SpawnScript: `[{0,3,2}, {3,0,4}]`

* Move Left → merges to `[4,0,0,0]` row0; spawn `{0,3,2}`.
* Move Down → state changes; spawn `{3,0,4}`.

Final Expect:

```
0 0 0 2
0 0 0 0
0 0 0 0
4 0 0 4
```

Score total `=4`.

---

## 10) Scoring Tests

### S1. Single merge

Given row `[2,2,0,0]` Left → `scoreΔ=4`.

### S2. Two merges in one line

`[2,2,4,4]` Left → `scoreΔ=4+8=12`.

### S3. Multiple rows per move (sum all merges)

From I10 above → `scoreΔ=16`.

### S4. No-op move

Any no-op → `scoreΔ=0`.

### S5. Merge created tile cannot merge again

`[2,2,2,0]` Left → only first pair merges → `scoreΔ=4`.

---

## 11) Spawn Logic Tests

### P1. Spawn only after state-changing move

* No-op: no spawn.

### P2. Spawn value distribution (production)

* With seeded RNG over many runs, approximate 0.9/0.1 distribution (statistical, non-deterministic).
* Not used in deterministic unit tests.

### P3. Scripted spawn placement/value

* Use SpawnScript; assert exact cell and value used; error if cell is non-empty or script is missing when required.

### P4. Spawn cannot overwrite non-empty cell

* If script requests an occupied cell, engine must **reject** (throw) or the test harness should flag invalid script (preferred).

---

## 12) Undo/Redo Tests

### UDO1. Basic undo after one move

* Apply state-changing move → undo → board/score/status identical to pre-move; `future` has one state.

### UDO2. Redo after undo

* From UDO1, redo → identical to post-move; `history` restored.

### UDO3. No-op does not affect history

* Apply no-op → `history` and `future` unchanged.

### UDO4. New move clears redo stack

* After undo, perform a different move → `future` must be cleared.

### UDO5. Undo respects spawn determinism

* Undo should revert spawned tile and score precisely.

---

## 13) Serialization Tests

### SER1. Round-trip fidelity

* `deserialize(serialize(state))` deep-equals original (board, score, status, config, and, if captured, RNG seed and remaining SpawnScript for test runs).

### SER2. Versioning

* If a `version` field is used, unknown future fields are ignored; known fields produce same state.

---

## 14) Legal Moves and Lose Detection Tests

### LGL1. legal\_moves on empty board

* All four moves legal (since a move would be a no-op, this depends on policy; recommended: **legal\_moves returns directions that change state**).
* For clarity: **legal\_moves(state)** returns only directions that **change** the board.

### LGL2. Mixed board

Given:

```
2 2 4 8
0 0 0 0
0 0 0 0
0 0 0 0
```

* Left and Right change state; Up/Down may be no-ops. Assert exact set.

### LGL3. No moves available → Lost

* See I13.

---

## 15) Edge Cases

### E1. Large merges near integer limits

* Ensure no overflow for typical values up to 131072+ in extended play.

### E2. Configurable board size (N≠4)

* N=3 and N=5 smoke tests: apply moves and ensure rules hold.

### E3. Win value other than 2048

* `win_value=1024`: detect win at 1024.

### E4. Initial spawn count

* `initial_spawns=1` or `2`; ensure no overlaps and score stays 0.

### E5. Restart behavior

* `init()` after a finished game yields a fresh state; no leakage from previous RNG/script.

### E6. Repeated move opposite directions

* Sequence: Left then Right on a symmetric board; verify no phantom merges.

### E7. Lines with multiple gaps

* `[2,0,0,2]` Left → `[4,0,0,0]`.

### E8. Merge after compression only if equal

* `[2,0,4,4]` Left → `[2,8,0,0]`, not `[4,4,0,0]`.

---

## 16) Comprehensive Test Suite (Numbered, Deterministic)

Each case uses format:

```
Case ID
Config overrides (optional)
Given:
<4 lines>
Move: <Left|Right|Up|Down>
SpawnScript: [ {r,c,v}, ... ]  // consumed at most one per state-changing move
Expect:
<4 lines>
ScoreΔ: <int>
Status: <Playing|Won|Lost|Won (continue)>
Notes: <optional>
```

### C01 — Pure slide left with spawn

```
Given:
0 2 0 0
0 0 0 0
0 0 0 0
0 0 0 0
Move: Left
SpawnScript: [{0,2,2}]
Expect:
2 2 0 0
0 0 0 0
0 0 0 0
0 0 0 0
ScoreΔ: 0
Status: Playing
```

### C02 — Single merge left

```
Given:
2 2 0 0
0 0 0 0
0 0 0 0
0 0 0 0
Move: Left
SpawnScript: [{1,1,2}]
Expect:
4 0 0 0
0 2 0 0
0 0 0 0
0 0 0 0
ScoreΔ: 4
Status: Playing
```

### C03 — Single merge right (order from right)

```
Given:
0 2 2 2
0 0 0 0
0 0 0 0
0 0 0 0
Move: Right
SpawnScript: [{1,0,4}]
Expect:
0 0 2 4
4 0 0 0
0 0 0 0
0 0 0 0
ScoreΔ: 4
Status: Playing
```

### C04 — Double merges in a row

```
Given:
2 2 4 4
0 0 0 0
0 0 0 0
0 0 0 0
Move: Left
SpawnScript: [{1,3,2}]
Expect:
4 8 0 0
0 0 0 2
0 0 0 0
0 0 0 0
ScoreΔ: 12
Status: Playing
```

### C05 — Triple equal tiles (only first pair merges)

```
Given:
2 2 2 0
0 0 0 0
0 0 0 0
0 0 0 0
Move: Left
SpawnScript: [{0,3,2}]
Expect:
4 2 0 2
0 0 0 0
0 0 0 0
0 0 0 0
ScoreΔ: 4
Status: Playing
```

### C06 — Gaps then merge

```
Given:
2 0 2 2
0 0 0 0
0 0 0 0
0 0 0 0
Move: Left
SpawnScript: [{1,1,2}]
Expect:
4 2 0 0
0 2 0 0
0 0 0 0
0 0 0 0
ScoreΔ: 4
Status: Playing
```

### C07 — Vertical up merges

```
Given:
2 0 2 0
2 0 2 0
0 0 0 0
0 0 0 0
Move: Up
SpawnScript: [{3,1,2}]
Expect:
4 0 4 0
0 0 0 0
0 0 0 0
0 2 0 0
ScoreΔ: 8
Status: Playing
```

### C08 — Vertical down merges

```
Given:
2 0 2 0
0 0 2 0
2 0 0 0
2 0 2 0
Move: Down
SpawnScript: [{0,1,2}]
Expect:
2 0 2 0
0 0 0 0
2 0 2 0
4 0 4 0
ScoreΔ: 8
Status: Playing
```

### C09 — No-op left (no spawn)

```
Given:
2 4 8 16
32 64 128 256
2 4 8 16
32 64 128 256
Move: Left
SpawnScript: [{0,0,2}]
Expect:
2 4 8 16
32 64 128 256
2 4 8 16
32 64 128 256
ScoreΔ: 0
Status: Playing
Notes: SpawnScript unchanged
```

### C10 — Spawn script invalid (occupied cell) → error

```
Given:
2 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
Move: Right
SpawnScript: [{0,3,2}]  // occupied after slide
Expect: Test must assert engine rejects invalid spawn or test harness flags script error
```

### C11 — Win (stop\_on\_win=true) blocks spawn

```
Config: stop_on_win=true
Given:
1024 1024 0 0
0    0    0 0
0    0    0 0
0    0    0 0
Move: Left
SpawnScript: [{3,3,2}]
Expect:
2048 0 0 0
0    0 0 0
0    0 0 0
0    0 0 0
ScoreΔ: 2048
Status: Won
Notes: Spawn not consumed
```

### C12 — Win (continue) consumes spawn

```
Config: stop_on_win=false
Given:
1024 1024 0 0
0    0    0 0
0    0    0 0
0    0    0 0
Move: Left
SpawnScript: [{3,3,2}]
Expect:
2048 0 0 0
0    0 0 0
0    0 0 0
0    0 0 2
ScoreΔ: 2048
Status: Won (continue)
```

### C13 — Lose detection (no empties, no merges)

```
Given:
2 4 2 4
4 2 4 2
2 4 2 4
4 2 4 2
Move: Up  // any
SpawnScript: []
Expect:
Same board
ScoreΔ: 0
Status: Lost
```

### C14 — Double merges across rows in one move

```
Given:
2 2 2 2
4 0 4 4
0 2 0 2
0 0 0 0
Move: Left
SpawnScript: [{3,3,2}]
Expect:
4 4 0 0
8 4 0 0
4 0 0 0
0 0 0 2
ScoreΔ: 4+4+8+4 = 20
Status: Playing
```

### C15 — Opposite direction after merge (no phantom second merge)

```
Given:
2 2 0 0
0 0 0 0
0 0 0 0
0 0 0 0
Move: Left
SpawnScript: [{0,3,2}]
→ Now board:
4 0 0 2
0 0 0 0
0 0 0 0
0 0 0 0
Next move: Right
SpawnScript: [{1,0,2}]
Expect:
0 0 4 2
2 0 0 0
0 0 0 0
0 0 0 0
ScoreΔ (second move): 0
Status: Playing
```

### C16 — Undo/Redo cycle

```
Given:
2 2 0 0
0 0 0 0
0 0 0 0
0 0 0 0
Move: Left
SpawnScript: [{0,3,2}]
→ Board A:
4 0 0 2
Undo → Back to initial
Redo → Board A again
Assert score and board identical at each step; history/future sizes correct.
```

### C17 — Serialization round-trip

```
Given:
2 0 2 4
0 4 0 4
0 0 0 0
0 0 0 0
Serialize → Deserialize → deep equal
```

### C18 — legal\_moves returns only state-changing directions

```
Given:
2 4 8 16
0 0 0 0
0 0 0 0
0 0 0 0
Expect: {Right, Left} legal? (Left changes, Right changes); {Up, Down} may be no-ops; assert exact set from engine implementation.
```

### C19 — Config: N=5 smoke test

```
Config: N=5
Given: 5×5 board with random tiles
Apply sequence Left, Up with SpawnScript for two spawns
Assert rule conformance, sizes, and scoring.
```

### C20 — Config: win\_value=1024

```
Config: win_value=1024, stop_on_win=true
Given:
512 512 0 0
0   0   0 0
0   0   0 0
0   0   0 0
Move: Left
Expect: status=Won; no spawn.
```

### C21 — No-op must not alter history

```
Given:
2 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
Move: Up (no change)
Assert history unchanged; no spawn consumed.
```

### C22 — Spawn on last empty cell

```
Given:
2 2 4 8
4 8 16 32
64 128 256 512
1024 2048 4096 0
Move: Left  // changes last row
SpawnScript: [{3,3,2}]
Expect last empty fills at (3,3)=2; assert no overwrite.
```

### C23 — Complex vertical with gaps and merges

```
Given:
2 0 2 2
2 2 0 2
0 2 2 0
0 0 0 0
Move: Up
SpawnScript: [{3,1,4}]
Expect:
4 4 4 4
0 0 0 0
0 0 0 0
0 4 0 0
ScoreΔ: 4+4+4+4 = 16
```

### C24 — Chain prevention in column

```
Given:
2 2 2 0
0 0 0 0
0 0 0 0
0 0 0 0
(Interpret as a **column** for Up: place these in one column)
Board:
2 0 0 0
2 0 0 0
2 0 0 0
0 0 0 0
Move: Up
SpawnScript: [{3,0,2}]
Expect:
4 2 0 0
0 0 0 0
0 0 0 0
2 0 0 0
ScoreΔ: 4
```

### C25 — Redo cleared after new branch

```
Start from C16 after Undo
Make a different move (e.g., Up) that changes state
Assert `future` cleared
```

---

## 17) Touch/Keyboard IO (Non-engine)

* **Keyboard**: Arrow keys; ignore repeats when game not changed; prevent default scrolling.
* **Touch**: Swipe detection with threshold (e.g., 20 px); ignore diagonal; if |dx|≈|dy| within deadzone, discard.
* **Input on terminal states**:

  * `stop_on_win=true`: ignore further moves.
  * `stop_on_win=false`: continue until Lost.

(These are not unit-tested at the engine level; E2E UI tests should simulate key/swipe and assert engine calls.)

---

## 18) Performance and Safety

* Engine operations are O(N²) per move.
* No recursion needed; avoid integer overflow (use 64-bit internally if available).
* Validate inputs from UI; directions must be enumerated; SpawnScript entries must pass bounds checks.

---

## 19) Acceptance Criteria Checklist

* All **Unit**, **Integration**, **Scoring**, **Spawn**, **Undo/Redo**, **Serialization**, **Legal Moves**, and **Edge** tests pass.
* Deterministic behavior under **SpawnScript**; seeded RNG reproducible.
* No spurious spawns on no-ops.
* Single-merge per tile per move guaranteed.
* Win and Lose states detected exactly as specified.
* Undo/redo/serialization are bit-exact round-trippable (including score and status).
* Code separated into **pure engine** and **UI** layers.

---

## 20) Suggested Property-Based Invariants (Optional)

1. After any move, the **multiset** of tile values (excluding the spawned tile) equals the multiset after merges (replacing pairs {x,x} with {2x}) and compression does not change the multiset.
2. Total sum of tile values after a state-changing move equals:

   ```
   prev_sum + spawn_value
   ```

   (since merges preserve sum, only spawn increases it).
3. Number of empty cells after a state-changing move equals:

   ```
   prev_empties - 1 + merges_count
   ```
4. If `legal_moves` is empty, `can_move` is false and status is **Lost** (unless already **Won** with stop).
5. Reversing a move (via **undo**) restores exact prior state, including RNG/script cursor.

---

**End of Document.**
